/**
 * *****************************************************************************
 * JNotify - Allow java applications to register to File system events.
 *
 * Copyright (C) 2011 - Matthias Zitzen
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 *
 ******************************************************************************
 * This is a Extension for FreeBSD file events.
 *
 * Author : Matthias Zitzen; m.zitzen@o-notation.org Oktober 2011,
 * Moenchengladbach, Germany
 *****************************************************************************
 */
package net.contentobjects.jnotify.freebsd;

import java.io.File;
import java.util.HashMap;
import java.util.Iterator;
import java.util.TreeSet;
import net.contentobjects.jnotify.IJNotify;
import net.contentobjects.jnotify.JNotify;
import net.contentobjects.jnotify.JNotifyException;
import net.contentobjects.jnotify.JNotifyListener;

/**
 * JNotifyAdapterFreeBSD <br/> When registering a directory all subfiles are
 * registered too. Subdirectories are only registered when subtree = true.<br/>
 * File renaming, removing and creating has to handled by the adapter. Kqueue
 * reports no effects like new filename. Also moved files out of the observed 
 * filesystem.<br/>
 * 
 * <h3>0.3.2</h3>
 * Renamed subimtes wasn't commited correctly.<br/>
 * 
 * 
 * Created on Oct 24, 2011
 *
 * @author $LastChangedBy: matthias $
 * @version $LastChangedRevision: 166 $ <br/> Date: $LastChangedDate: 2013-02-12
 * 22:13:35 +0100 (Di, 12 Feb 2013) $
 */
public class JNotifyAdapterFreeBSD implements IJNotify
{

    /**
     * Version String; generated by SVN.
     */
    public final static String REVISON = "$LastChangedRevision: 166 $";
    public final static String VERSION = "JNotify FreeBSD 0.3.2"; // not published
    /**
     * Filepathseparator.
     */
    public final static String SEP = "/";
    private int watchpoint = 0;
    final private HashMap<Integer, PathController> fd2PC; //filesystem-descripor -> kqeue
    final private HashMap<Integer, PathController> wp2PC; //internal counter
    boolean isDirectory = false;
    
    public JNotifyAdapterFreeBSD()
    {
//        System.out.println("JNotifyAdapter Version:" + VERSION);
        JNotify_freebsd.setNotifyListener(new BSDNotifyListener()
        {

            @Override
            public void notify(String path, int wd, int mask, int action)
            {
                try
                {
                    notifyChanges(path, wd, mask, action);
                }
                catch (RuntimeException ex)
                {
                    System.out.println("ERROR:JNotifyAdapterFreeBSD.BSDNotifyListener.notify:" + ex.getMessage());
                }
            }
        });
        fd2PC = new HashMap<Integer, PathController>();
        wp2PC = new HashMap<Integer, PathController>();
    }

    @Override
    public int addWatch(String path, int mask, boolean watchSubtree, JNotifyListener listener) throws JNotifyException
    {
        int bsdMask = 0;
        if ((mask & JNotify.FILE_CREATED) != 0)//only if folder is observed
        {
            bsdMask |= JNotify_freebsd.BSD_EXTEND;
            bsdMask |= JNotify_freebsd.BSD_WRITE;
        }
        if ((mask & JNotify.FILE_DELETED) != 0)
        {
            bsdMask |= JNotify_freebsd.BSD_DELETED;
        }
        if ((mask & JNotify.FILE_MODIFIED) != 0)
        {
            bsdMask |= JNotify_freebsd.BSD_ATTRIBUTE;
            bsdMask |= JNotify_freebsd.BSD_EXTEND;
            bsdMask |= JNotify_freebsd.BSD_WRITE;
        }
        if ((mask & JNotify.FILE_RENAMED) != 0)
        {
            bsdMask |= JNotify_freebsd.BSD_RENAME;
        }
        bsdMask |= JNotify_freebsd.BSD_LINK;
        path = deleteLastSeparator(path);
        final int bsdwp = JNotify_freebsd.addWatch(path, bsdMask);
        //filling the controller
        PathController pathCtrl = new PathController(bsdMask, mask, watchpoint, bsdwp, path, watchSubtree, listener);
        fd2PC.put(bsdwp, pathCtrl);
        wp2PC.put(watchpoint, pathCtrl);
        if (pathCtrl.isDirectory())
        {
            this.registerSubFiles(pathCtrl, path, bsdMask, watchSubtree);
        }
        return watchpoint++;
    }

    private static String deleteLastSeparator(String token)
    {
        if(token.endsWith(SEP))
            return token.substring(0, token.length()-1);
        else
            return token;
    }
    
    /**
     * Registers all files in a pathCtrl.
     *
     * @param wd
     */
    private void registerSubFiles(PathController pathCtrl, String path, int mask, boolean subTree) throws JNotifyException
    {
        File f = new File(path);
        File[] fs = f.listFiles();
        final int l = fs.length;
        for (int i = 0; i < l; i++)
        {
            int filesystemWP = JNotify_freebsd.addWatch(fs[i].getPath(), mask);
//            System.out.println("SubFiles="+fs[i].getPath()+";FD="+bsdwp);
            pathCtrl.addBSDWatchpoint(filesystemWP);
            pathCtrl.addSubfile(path + ((path.endsWith(SEP)) ? "" : SEP) + fs[i].getName());
            fd2PC.put(filesystemWP, pathCtrl);
            //add subtree
            if (fs[i].isDirectory() && subTree)
            {
                this.registerSubFiles(pathCtrl, fs[i].getPath(), mask, subTree);
            }
        }
    }

    /**
     * Removes a watch via watchpointer, !not a bsdwp!
     *
     * @param wp
     * @return true when removing was successfull.
     * @throws JNotifyException
     */
    @Override
    public synchronized boolean removeWatch(int wp) throws JNotifyException
    {
        if (wp2PC.containsKey(wp))
        {
            PathController pw = wp2PC.get(wp);
            //wp and object identical
            if (pw.watchpointer == wp)
            {
                JNotifyException e = null;
                boolean flag = true;
                try
                {
                    JNotify_freebsd.removeWatch(pw.fd);
                }
                catch(JNotifyException ex)
                {
                    e = ex;
                    flag = false;
                }
                //delete all objects from subtree
                Iterator<Integer> it = pw.bsdwps.iterator();
                while (it.hasNext())
                {
                    try
                    {
                        JNotify_freebsd.removeWatch(it.next());
                    }
                    catch(JNotifyException ex)
                    {
                        e = ex;
                        flag = false;
                    }
                }
                pw.bsdwps.clear();
                pw.subfiles.clear();
                fd2PC.remove(pw.fd);
                wp2PC.remove(wp);
                pw = null;
                if(!flag)
                {
                    throw e;
                }
                return true;
            }
            return false;
        } 
        else
        {
            return false;
        }
    }

    /**
     * Looks for file changes in a folder, when files are created or removed.
     *
     * @param pw
     * @param f
     * @return
     */
    private String checkFilesystem(PathController pw, File f)
    {
        final String[] fnames = f.list();
        final int l = fnames.length;
        final String prefix = f.getPath();
        String listed_fnames = null;
        String back = "";
        for (int i = 0; i < l; i++)
        {
            listed_fnames = prefix + SEP + fnames[i];
            //System.out.println("checkingFile="+nn);
            //wds subfilelist is not containing listed filenames, then it must be the new file
            if (!pw.subfiles.contains(listed_fnames))
            {
                back = listed_fnames;
                break;
            }
        }
        return back;
    }

    /**
     * For debug only
     *
     * @param action
     */
    private void printAction(int action, String path)
    {
        System.out.println("PATH=" + path);
        System.out.println("WRITE=" + ((action & JNotify_freebsd.BSD_WRITE) == 0 ? "0" : "1"));
        System.out.println("EXTEND=" + ((action & JNotify_freebsd.BSD_EXTEND) == 0 ? "0" : "1"));
        System.out.println("RENAME=" + ((action & JNotify_freebsd.BSD_RENAME) == 0 ? "0" : "1"));
        System.out.println("DELETE=" + ((action & JNotify_freebsd.BSD_DELETED) == 0 ? "0" : "1"));
        System.out.println("LINK=" + ((action & JNotify_freebsd.BSD_LINK) == 0 ? "0" : "1"));
        System.out.println("ATTRIBUTE=" + ((action & JNotify_freebsd.BSD_ATTRIBUTE) == 0 ? "0" : "1"));
        System.out.println("---");
    }

    /**
     * Notified by the static lib.<br/> BSD file events via kqueue<br/> 
     * <ul>
     * <li>touch folder = ATTRIBUTE folder</li> 
     * <li>touch folder/file = ATTRIBUTE folder/foo</li> 
     * <li>create folder/file = WRITE folder/ (parent folder only)</li> 
     * <li>delete folder/file = WRITE folder/ (parent folder only) -> DELETE folder/file</li>
     * <li>rename folder/file -> file2 = WRITE folder/ -> RENAME folder/file</li>
     * <li>write to folder/file = WRITE EXTEND folder/file</li>
     * </ul>
     *
     * @param path Path of the event.
     * @param bsdwp Watchpoint of the Library.
     * @param mask Eventmask.
     * @param action Actionmask.
     */
    protected synchronized void notifyChanges(String path, int bsdwp, int mask, int action)
    {
        // folder created action = 18
        // file created action = 2
        PathController pc = fd2PC.get(bsdwp);
        if ((action & JNotify_freebsd.BSD_WRITE) != 0)
        {
            File f = new File(path);
            isDirectory = f.isDirectory();
            if (isDirectory)
            {
                if ((pc.jmask & JNotify.FILE_MODIFIED) != 0)
                {
                    pc.notifyFileModified(path);
                }
                if(action == 2)
                {
                    //kqueue notifies the folder when a file is created
                    //there is no other event
                    //check if new file is created
                    String newfile = this.checkFilesystem(pc, f);
                    //new file
                    if (newfile.length() > 0)
                    {
                        int newbsdwp;
                        //adding new file to the subfilelist
                        try
                        {
                            newbsdwp = JNotify_freebsd.addWatch(newfile, pc.mask);
                            pc.addSubfile(newfile);
                            pc.bsdwps.add(newbsdwp);
                            fd2PC.put(newbsdwp, pc);
                            if ((pc.jmask & JNotify.FILE_CREATED) != 0)
                            {
                                pc.notifyFileCreated(newfile);
                            }
                        }
                        catch (JNotifyException ex)
                        {
                            System.out.println("Error JNotifyAdapterFreeBSD.notifyChanges:addWatch " + ex.getMessage() + "; " +ex.getErrorCode());
                        }
                    }
                }
            } 
            else
            {
                pc.notifyFileModified(path);
            }
        } 
        else if ((action & JNotify_freebsd.BSD_EXTEND) != 0)
        {
            if ((pc.jmask & JNotify.FILE_MODIFIED) != 0)
            {
                pc.notifyFileModified(path);
            }
        }

        if ((action & JNotify_freebsd.BSD_ATTRIBUTE) != 0)
        {
            if ((pc.jmask & JNotify.FILE_MODIFIED) != 0)
            {
                pc.notifyFileModified(path);
            }
        }
        if ((action & JNotify_freebsd.BSD_RENAME) != 0)
        {
            if ((pc.jmask & JNotify.FILE_RENAMED) != 0)
            {
                pc.notifyFileRenamed(path);
            }
            //the new file name is still registered
            //remove the old one
            pc.bsdwps.remove(bsdwp);
            pc.subfiles.remove(path);
            try
            {
                JNotify_freebsd.removeWatch(bsdwp);
            }
            catch (JNotifyException ex)
            {
                System.out.println("Adapter.notifyChanges:BSD_RENAME:" + bsdwp + " Watchpoint couldn't remove:" + ex.getMessage() + "; " + ex.getErrorCode());
            }
            //if folder, all other items muss be replaced with new foldername
            if(pc.lastpath.length()>0) //only if a new folder is in the observed filepath
            {
                if(isDirectory)
                {
                    String[] items = pc.subfiles.toArray(new String[]{});
                    for(int i=0;i<pc.subfiles.size();i++)
                    {
                        if(items[i].contains(path + SEP))//find old pathnames
                        {
                            pc.subfiles.remove(items[i]);
                            String replace = items[i].replace(path, pc.lastpath);
                            pc.subfiles.add(replace);
                        }
                    }
                    isDirectory = false;
                }
            }
        }
        if ((action & JNotify_freebsd.BSD_DELETED) != 0)
        {
            if ((pc.jmask & JNotify.FILE_DELETED) != 0)
            {
                pc.notifyFileDeleted(path);
            }
            //is it root
            if (pc.fd == bsdwp)
            {
                try
                {
                    this.removeWatch(pc.watchpointer);
                }
                catch (JNotifyException ex)
                {
                    System.out.println("Adapter.notifyChanges:BSD_DELETE:" + bsdwp + " Watchpoint couldn't remove:" + ex.getMessage() + "; " + ex.getErrorCode());
                }
            } 
            else //subfiles
            {
                //watchdata clearing
//                System.out.println("Remove BSDwp="+bsdwp);
                pc.bsdwps.remove(bsdwp);
                pc.subfiles.remove(path);
                fd2PC.remove(bsdwp);
                try
                {
                    JNotify_freebsd.removeWatch(bsdwp);
                }
                catch (JNotifyException ex)
                {
                    System.out.println("Adapter.notifyChanges:BSD_DELETE:" + bsdwp + " Watchpoint couldn't remove:" + ex.getMessage() + "; " + ex.getErrorCode());
                }
            }
        }
    }

    /**
     * Class for holding the main data for a watch.
     */
    private static class PathController
    {

        final int mask;
        final int jmask;
        final int watchpointer;
        final int fd;//fildedescriptor
        final String path;
        String lastpath;
        boolean watchSub;
        final JNotifyListener listener;
        final boolean isFolder;
        final TreeSet<Integer> bsdwps;
        final TreeSet<String> subfiles;
//        final int delta;

        public PathController(int mask, int jmask, int wp, int fd, String path, boolean watchSub, JNotifyListener listener)
        {
            this.mask = mask;
            this.jmask = jmask;
            this.watchpointer = wp;
            this.fd = fd;
            File f = new File(path);
            isFolder = f.isDirectory();
            this.path = path;
            //some correction for the path-strings
//            if (isFolder && path.endsWith(SEP))
//            {
//                if(path.endsWith(SEP))
//                {
//                    delta = 0;
//                }
//                else
//                {
//                    delta = 1;
//                }
//            } 
//            else
//            {
//                delta = 0;
//            }
            this.watchSub = watchSub;
            this.listener = listener;
            bsdwps = new TreeSet<Integer>();
            subfiles = new TreeSet<String>();
        }

        public boolean isDirectory()
        {
            return isFolder;
        }

        /**
         * BSDWatchpoint = Filesystemwatchpoint
         * @param wp 
         */
        public void addBSDWatchpoint(int wp)
        {
            bsdwps.add(wp);
        }

        public void addSubfile(String path)
        {
            this.subfiles.add(path);
            this.lastpath = path;
        }

        public void notifyFileRenamed(String name)
        {
            listener.fileRenamed(watchpointer, path, name, lastpath);
        }

        public void notifyFileModified(String name)
        {
            //root
            if (name.equals(path))
            {
                listener.fileModified(watchpointer, path, path);
            } 
            else
            {
//                listener.fileModified(watchpointer, path, name.substring(path.length() + delta));
                listener.fileModified(watchpointer, path, name);
            }
        }

        public void notifyFileDeleted(String name)
        {
            subfiles.remove(name);
            listener.fileDeleted(watchpointer, path, name);
        }

        public void notifyFileCreated(String name)
        {
            listener.fileCreated(watchpointer, path, name);
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder();
            sb.append("Path=").append(path).append(";fd=").append(fd).append(";wp=").append(watchpointer);
            sb.append("\n").append(subfiles);
            return sb.toString();
        }
    }
}
